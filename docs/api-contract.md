# Engine ↔ MAUI API Contract

Version: 1.0
Status: Proposed
Resolves: [Issue #1](https://github.com/mcp-tool-shop-org/soundboard-maui/issues/1)

---

## Overview

The MAUI client communicates with the voice-soundboard engine over a local
network connection. The engine runs as a separate process on the same machine.

This contract defines what MAUI can call, what the engine must return, and
what neither side is allowed to assume about the other.

---

## 1. Transport

**Both HTTP and WebSocket on a single port.**

| Layer | Protocol | Purpose |
|-------|----------|---------|
| Control plane | HTTP | Commands, discovery, metadata |
| Data plane | WebSocket | Streaming audio, realtime state |

```
http://localhost:{port}/api/*
ws://localhost:{port}/stream
```

Default port: `8765`

**Fallback rule:** MAUI must function if WebSocket is unavailable.
In that case, use `POST /api/speak` (returns a WAV URL instead of streaming).

---

## 2. Message Envelope

All messages use JSON over UTF-8.

```json
{
  "type": "command | event | error",
  "request_id": "uuid-v4",
  "payload": { ... }
}
```

Rules:
- `type` is always present
- `request_id` is always present (generated by sender)
- `payload` contains action-specific data
- Unknown fields are ignored (forward compatibility)
- No binary frames (audio is base64-encoded in JSON)

---

## 3. Control Plane (HTTP)

### GET /api/health

Engine readiness check. MAUI calls this on startup.

**Response:**
```json
{
  "status": "ready",
  "engine_version": "1.1.0",
  "api_version": 1
}
```

| Field | Type | Description |
|-------|------|-------------|
| `status` | string | `"ready"` or `"loading"` |
| `engine_version` | string | Semver version of the engine |
| `api_version` | int | API contract version (matches `API_VERSION` in engine) |

### GET /api/voices

**Response:**
```json
{
  "voices": [
    { "id": "af_bella", "name": "Bella", "gender": "female", "accent": "American" },
    { "id": "bm_george", "name": "George", "gender": "male", "accent": "British" }
  ]
}
```

### GET /api/presets

**Response:**
```json
{
  "presets": [
    { "id": "assistant", "voice": "af_bella", "description": "Friendly, conversational" },
    { "id": "narrator", "voice": "bm_george", "description": "Calm, documentary" }
  ]
}
```

### POST /api/speak

Non-streaming speech generation. Returns a URL to the generated WAV file.

**Request:**
```json
{
  "text": "Hello world",
  "preset": "assistant",
  "voice": "af_bella",
  "emotion": "happy",
  "speed": 1.0
}
```

All fields except `text` are optional.

**Response:**
```json
{
  "audio_url": "/api/audio/{id}.wav",
  "duration_seconds": 1.2,
  "voice_used": "af_bella"
}
```

### POST /api/stop

Stop current playback.

**Response:**
```json
{
  "stopped": true
}
```

### GET /api/audio/{id}.wav

Serves a previously generated audio file. Standard HTTP range headers supported.

---

## 4. Data Plane (WebSocket)

Connect to `ws://localhost:{port}/stream`.

### Client → Engine: Speak Command

```json
{
  "type": "command",
  "request_id": "550e8400-e29b-41d4-a716-446655440000",
  "payload": {
    "action": "speak",
    "text": "Hello world",
    "preset": "assistant",
    "voice": "af_bella",
    "emotion": "happy",
    "speed": 1.0
  }
}
```

All payload fields except `action` and `text` are optional.

### Engine → Client: State Event

```json
{
  "type": "event",
  "request_id": "550e8400-e29b-41d4-a716-446655440000",
  "payload": {
    "state": "started"
  }
}
```

States: `started` → `streaming` → `finished`

### Engine → Client: Audio Chunk

```json
{
  "type": "audio_chunk",
  "request_id": "550e8400-e29b-41d4-a716-446655440000",
  "payload": {
    "format": "pcm16",
    "sample_rate": 24000,
    "channels": 1,
    "data": "<base64-encoded PCM16 bytes>"
  }
}
```

Rules:
- Chunks arrive in time order
- `format` is always `pcm16` at v1
- `sample_rate` is always `24000` at v1 (Kokoro engine)
- Final chunk is followed by a `finished` state event

### Client → Engine: Stop Command

```json
{
  "type": "command",
  "request_id": "uuid",
  "payload": {
    "action": "stop"
  }
}
```

### Engine → Client: Error

```json
{
  "type": "error",
  "request_id": "uuid",
  "payload": {
    "code": "invalid_voice",
    "message": "Voice 'xyz' not found. Available voices: af_bella, bm_george, ..."
  }
}
```

---

## 5. Audio Format

| Property | Value |
|----------|-------|
| Format | PCM16 (signed 16-bit little-endian) |
| Sample rate | 24,000 Hz |
| Channels | 1 (mono) |
| Encoding (WebSocket) | Base64 in JSON |
| Encoding (HTTP) | WAV file |

No compression at v1. MAUI decodes base64 → PCM16 → audio output.

---

## 6. Discovery

MAUI finds the engine using this strategy:

1. Check last known port (persisted in app settings)
2. Try default port (`8765`)
3. Call `GET /api/health`
4. If unreachable, show "Engine not found" with instructions

No mDNS, no broadcast discovery, no registry.

---

## 7. Version Compatibility

On startup, MAUI reads `api_version` from `/api/health`.

| Condition | Behavior |
|-----------|----------|
| `api_version` matches | Proceed normally |
| `api_version` minor mismatch | Proceed with warning |
| `api_version` major mismatch | Hard fail with explanation |
| Engine unreachable | Show connection error |

---

## 8. Non-Goals

MAUI must NOT:

- Control vocology parameters
- Modify synthesis pipelines
- Access research or experimental flags
- Import engine Python code
- Assume real-time latency guarantees
- Manage engine lifecycle (start/stop the engine process)
- Access the filesystem directly for audio files

---

## 9. Future Extensions (Not in v1)

These may be added in future contract versions:

- Emotion blending parameters
- Multi-speaker dialogue commands
- Voice cloning triggers
- Audio format negotiation (opus, mp3)
- Engine process management
- Preset creation from MAUI

Each extension requires a contract version bump and agreement from both sides.
